---
layout:     post
title:      "The TLS Protocol V1.0"
subtitle:   "RFC2246"
date:       2019-03-17
author:     "XiaoYu"
header-img: "img/RFC2246.jpg"
catalog:     True
tags:
    - Cyber Security
    - Protocol
    - RFC
---

> 对TLS协议的学习记录，本文为翻译。
> Copyright (C) The Internet Society (1999).  All Rights Reserved.

## 摘要
本文档规定了传输层安全协议(TLS)的1.0版本。TLS可以使互联网中的通信不受干扰。该协议允许客户端/服务器以一种能够防止窃听、篡改和消息伪造的方式进行通信。

## 引言
TLS协议的主要目标是在两个通信应用之间提供隐私保护和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。在最底层，在一些可靠的传输协议之上（如TCP），是TLS记录协议。TLS记录协议提供的安全连接有两个基本特性：

* 连接是私有的。对称加密用于数据加密（例如DES、RC4）。这种对称加密的密钥为每个连接唯⼀生成的，并且基于另一个协议协商的机密信息（如TLS握手协议）。记录协议也可以在没有加密的情况下使⽤。
* 连接是可靠的。消息传输过程包括使用加密的MAC进行完整性校验。使用一些安全的哈希函数（如SHA、MD5）进行MAC计算。记录协议同样可以在没有MAC的情况下运行，但这通常仅在另一个协议利用记录协议作为传输工具来协商安全参数的时候才会发生。

TLS记录协议⽤于封装各种高级协议。 一个被封装的协议就是TLS握手协议，它允许服务器和客户端彼此认证，并在应⽤用协议发送或接收其第一个数据字节之前协商加密算法和加密密钥。TLS握手协议提供的安全连接有三个基本属性: 

* 对等实体的身份认证可以使用非对称加密或公钥加密（例如，RSA，DSS等）算法。该认证可以是可选的，但通常对于至少一个对等体是必需的。 
* 共享机密信息的协商是安全的：协商的机密信息不可被窃听者使用，并且对于任何经过身份验证的连接，即使能够将⾃己置于连接中的攻击者也⽆法获得该机密信息。 
* 协商是可靠的：没有攻击者可以在不被通信方发现的情况下修改协商通信。

TLS的一个优点是它与应⽤层协议无关。高层协议可以透明地层叠在TLS协议之上。然⽽，TLS标准没有指定协议如何使用TLS添加安全性; 关于如何初始化TLS握手过程以及如何解释交换的认证证书的决定取决于在TLS之上运⾏的协议的设计者和实现者的判断。 

## 目的
TLS协议的按优先级排列的目标：

1. 加密安全：TLS应该被用来建立参与双方的安全连接。
2. 互操作性：独立的程序员应该可以开发基于TLS的应用程序，并且可以成功交换加密参数而不需要了解彼此的代码。
3. 可扩展性：TLS旨在提供一个能将新的公钥加密和批量加密方法结合到一起的框架。这同时达到了一下两个子目标：避免了对新的协议的需要（且会引入新的风险）以及避免重新实现整个安全程序库。
4. 相对的效率：加密操作往往是CPU密集型的，特别是公钥加密。因此，TLS集成了一个可选的缓存技术以减少连接的建立次数。另外，减少网络活动也已被纳入考虑。

## 本文档的目的
本文档和TLS协议本身基于Netscape发布的SSL 3.0协议规范。TLS和SSL3.0的差异并不大，但它们之间是无法相互操作的（尽管设计了使TLS降级为SSL3.0的机制）。本文档主要面向要实现该协议的读者以及对它进行密码分析的人。因此本文档的写作目的也是为了上述两个人群的需要。所以很多独立于算法的数据结构和规则都被包含在文档主体中，这样可以方便的找到它们。

本文档并不是要提供服务或接口定义的细节，尽管它包含了维持安全性的一些策略。

## 描述语言
本文档使用外部形式表示数据的格式。将使用以下的十分基础的甚至有些随意的语法形式。语法结构采取自多个不同的来源。虽然它在语法上与C语言类似，并且亦或操作在语法和意图上都是类似的，但设置太多的类似并行语法是有风险的。描述语言只是用在本文档中，不应该有超出此目标的一般应用。

### 基本块的大小
所有数据项的表示形式都被明确指定了。最基本的数据块的大小为1字节。多字节的数据项是由单个字节串联而成的，从左到右，自顶向下。多字节数据项形式如下：
`value = (byte[0] << 8*(n-1) | (byte[1] << 8*(n-1)) | ... | byte[n-1])`
多字节项的字节顺序按照网络数据的`Big endian`格式。

### 其他
注释以`/*`开始，以`*/`结束。可选项使用两个方括号来包裹。包含未做解释的数据字节对象称为`opaque`类型。

### 向量
一个向量是一个同类数据元素的流（一维数组）。可以在编写文档时指定向量的大小，也可以在运行时指定。一般指定向量的字节数而不是数据类型的数量。指定新的类型`T`是固定长度向量的语法是：
`T  T'[n]`
这里的`T'`占据了`n`个字节，`n`是`T`的大小的倍数。 向量的长度不包括在编码流中。
在下面的例子中，`Datum`定义为三个连续的未做解释的字节，`Data`定义为3个连续的`Datum`，总共9个字节。
`opaque Datum[3];    /*3个未解释的字节*/`
`Datum Data[9];      /*3个连续的3字节向量*/`
可变长度的向量可以通过指定合法的的下标范围来定义，使用这种标注`<floor..ceiling>`。编码后，向量的实际长度会保存在实际内容的前面，长度将以一个数字的形式表示，消耗必要的字节数以保持向量的指定最大长度。长度字段为零的向量称为空向量。
`T T'<floor..ceiling>`
在下面的例子中，强制要求是一个向量必须包含300到400个`opaque`类型的字节。它不可能为空，实际长度字段为两个字节（UInt16），足以表示400的大小（见4.4节）。而且，可以表示到800字节的数据，400个UInt16类型元素，可能为空。编码形式在头部包含两个字节的长度字段。，编码后的长度必须是单个元素的长度的偶倍数。
`opaque mandatory<300..400>;  /*长度字段占两个字节，不能为空*/`
`uint16 longer<0..800>;       /*0到400个16比特的无符号整数*/`

### 数字
基本的数字数据类型是一个无符号的字节（uint8）。所有更大的数字数据都是固定的多个字节级联，同样是无符号的。下面是数字的类型：
`uint8 uint16[2]`
`uint8 uint24[3]`
`uint8 uint32[4]`
`uint8 uint64[8]`
所有值都以网络中的“大端”序存储，16进制的uint32`01020304`等于十进制`16909060`。

### 枚举
一种额外的稀疏数据类型称为枚举，枚举类型的字段只能是定义中声明的值，每个定义都是不同的类型。只有相同类型的枚举值才能被比较。每个枚举的元素都要赋值，如下所示。因为枚举的元素是无序的，它们可以以任意顺序赋不同的值。
`enum {e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;`
枚举在字节流中占⽤与其最大定义的值一样多的空间。以下定义将生成一个字节用于携带颜色类型的字段。 
`enum { red(3), blue(5), white(7) } Color;`
⼈们可以可选地指定一个没有关联标签的值来强制度定义而不定义多余的元素。在以下示例中，`Taste`将在数据流中消耗两个字节，但只能取值为1,2或4。 
`enum { sweet(1), sour(2), bitter(4), (32000) } Taste`
枚举的元素的名称在定义的类型范围内。在第一个示例中，对枚举的第二个元素的完全指定引用将是`Color.blue`。如果⽬标明确指定，则不需要这种指定。 
`Color color = Color.blue; /* overspecified, legal */`
`Color color = blue;       /* correct, type implicit */`
对于从未转换为外部表示的枚举，可以省略数字信息。
`enum { low, medium, high } Amount;`

### 构造类型
构造类型可以由原始类型创建。每个声明描述一种新的，独特的类型。定义的语法与`C`十分类似。
```
struct {
	T1 f1;
	T2 f2;
	...
	Tn fn;
} [[T]];
```
结构中的字段可以使用类型名进行限定，使用的语法非常类似于枚举的语法。例如，`T.f2`指之前定义的第二个字段。结构体的定义是可以嵌套的。

#### 变体
定义的结构可能基于环境中可用的一些信息具有变体。选择器必须是枚举类型，该类型定义了结构定义的可能变体。对于选择器中声明的枚举的每个元素，必须有一个`arm`情况。变体结构的主体可以给出一个标签以供引用。表示语言没有规定在运行时选择变体的机制。

### 加密属性
四种加密操作：数字签名、流密码加密、分组加密和公钥加密分别被指定为数字签名、流加密、分组加密和公钥加密。一个字段的加密处理是通过在字段的类型规范之前加上适当的关键字来指定的。加密密钥由当前会话状态指定（见连接状态）。

在数字签名中，单向哈希函数常用来作为数字签名的输入。数字签名编码为一个`opaque`向量`<0..2^16-1>`，它的长度由签名算法和密钥决定。

在RSA签名中，两个哈希值组成一个36字节的结构被签名（一个由SHA产生，一个由MD5产生）。它使用PKCS #1 块 类型0或类型1编码，如PKCS中所述。

在DSS中，SHA产生的20字节的哈希值直接通过数字签名算法，而没有额外的哈希。这将产生两个值，r和s。DSS的签名是一个`opaque`向量，它的内容是DER编码形式：
```
Dss-Sig-Value  ::=  SEQQUENCE  {
     r       INTEGER,
     s       INTEGER
}
```

在流密码加密中，明文与由安全密钥伪随机数产生器输出的相同大小的数据进行异或。

在分组加密中，每个明文分组被加密为一个密文分组。所有的分组加密过程都经过CBC（密文分组链接）模式完成，并且所有被加密的分组都是分组长度的倍数。

在公钥加密中，公钥加密算法加密的结果只能由对应的私钥解密。一个公钥加密元素被编码为`opaque`向量`<0..2^16-1>`，它的长度由签名算法和密钥指定。

一个RSA加密的数据以PKCS #1 分组类型2编码，如PKCS中的描述。

在如下的例子中：
```
stream-ciphered struct  {
    uint8 field1;
    uint8 field2;
    digitally-signed opaque hash[20];
} UserType;
```
哈希的内容被用作签名算法的输入，然后整个结构通过流密码加密。该结构的长度相当于`field1`和`field2`的两个字节以及两个字节的签名长度，还有签名算法的输出的长度，因为签名的算法和密钥都是已知的，那么长度也是已知的。

### 常量
可以通过为所需要的类型声明符号并赋值来定义常量类型。以下类型不能赋值(`opaque`，可变长向量，含有`opaque`的结构体)。无字段的多元素结构体或向量可以被省略。 
例如，
```
struct {
	uint8 f1;
	uint8 f2;
} Example1;

Example1 ex1 = {1, 4};
```

## HMAC和伪随机函数
TLS 记录层和握手层的一些操作需要用到带密钥的MAC，这是通过密钥保护的一些数据的安全摘要。不知道这个密钥是无法伪造MAC的。我们在这里使用HMAC，如[HMAC]的描述。

HMAC可以与各种不同的哈希算法一起使用。TLS在握手中使用两种：MD5和SHA-1，分别定义为HMAC_MD5(秘密，数据)和HMAC_SHA(秘密，数据)。额外的哈希算法可以定义在加密套件中，并用以保护记录数据，MD5和SHA-1被硬编码到该版本的握手协议中。

另外，为了密钥生成和验证，需要一种将私密信息扩展到数据块的构造方法。这个伪随机函数将私密信息，种子和身份标签作为输入并产生一个任意长度的输出。

为了伪随机函数尽可能的安全，它使用两种哈希算法，这样只要有一个足够安全就可以保证安全性。

首先，我们定义一个数据扩展函数，`P_hash(secret, data)`，它使用单个哈希函数将secret和seed扩展为任意数量的输出: 
```
P_hsah(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                       HMAC_hash(secret, A(2) + seed) +
                       HMAC_hash(secret, A(3) + seed) + ...
```
其中`+`指串连。
`A()`的定义如下：
```
A(0) = seed
A(i) = HMAC_hash(secret, A(i-1))
```

`P_hash`可以无限迭代以产生足够长度的输出数据。例如，如果使⽤`P_SHA-1`来创建64字节的数据，则必须迭代4次(通过A(4))，产生80字节的输出数据；最终迭代的最后16个字节将被丢弃，留下64个字节的输出数 据。 

TLS的伪随机函数是通过将私密信息分割成两半，其中一半用`P_MD5`生成数据，另一半⽤`P_SHA-1`生成数据， 然后将这两个扩展函数的输出进行异或。

S1和S2是私密信息的两半，每个都是相同的⻓度。 S1从secret的前半部分采取，S2是从下半部采取的。他们的长度是通过将私密信息的⻓度除以2来得出的; 因此，如果原始secret是奇数个字节长，则S1的最后⼀个字节 将与S2的第⼀个字节相同。 

 ```
 L_S = length in bytes of secret;
 L_S1 = L_S2 = ceil(L_S / 2);
 ```

如上所述，secret被分成两半(可能共享一个字节)，S1取第一个长为`L_S1`的字节，S2取最后一个长`L_S2`的字节。 

然后将PRF定义为将两个伪随机流混合在⼀起的结果。 
```
PRF(secret, label, seed) = P_MD5(S1, label+seed) XOR
                           P_SHA-1(S2, label+ seed);
```
标签是一个ASCII字符串。它应该被包括在给定的没有长度字节或尾随空字符的确切形式。 例如，label “slithy toves” 将通过哈希以下字节来处理: 
`73 6C 69 74 68 79 20 74 6F 76 65 73`

请注意，由于MD5产生16字节输出，SHA-1产生20字节输出，因此内部迭代的边界将不对齐; 为了生成80字节的输出，将`P_MD5`通过`A(5)`迭代，⽽`P_SHA-1`将仅迭代`A(4)`。

## TLS记录协议
TLS 记录协议是分层协议。在每一层，消息包扩用于长度、描述、内容的字段。记录协议传送数据，将数据分片为可管理的块、可以选择压缩数据、使用MAC、加密、并发送结果。接收到的数据将被解密、验证、解压、并重新封装，最后分发到高层客户端。

本文档描述了四个记录协议的客户端：握手协议、警报协议、密码规范更改协议和应用数据协议。为了允许对TLS协议的扩展，记录协议可以支持附加的记录类型。Any new record types should allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.2)。如果一个TLS的实现接收到它不理解的记录类型，则应该忽略它。任何设计用于 TLS的协议都必须仔细设计，以应对所有可能的攻击。请注意，由于记录的类型和长度不受加密保护，因此 应注意尽量减少这些值的流量分析值。 

### 连接状态
TLS连接状态是TLS记录协议的操作环境。它规定了了压缩算法、加密算法和MAC算法 。此外，这些算法的参数是已知的：MAC secret和用于读取和写⼊的连接的批量加密密钥和初始向量IV。在逻辑上，总是有四个连接状态未完成：当前的读写状态以及待处理的读写状态。所有记录都以当前的读写状态进行处理。挂起状态的安全参数可以通过TLS握⼿协议来设置，⽽握手协议可以选择性地使两个待处理状态中的任何一个状态为当前状态，在这种情况下，适当的当前状态被处理并替换为挂起状态;待处理状态然后重新初始化为空状态。将尚未使用安全参数初始化的状态设为当前状态是非法的。初始当前状态总是指定不使用加密、压缩、和MAC。 

TLS连接的读写状态的安全参数通过提供以下值来设置: 

连接端
	实体是否被视为“客户端”或“服务器”。 

批量加密算法
	⽤于批量加密的算法。 本规范包括该算法的密钥⼤小、该密钥的安全程度、分组加密还是流加密，分组的块⼤小(如果适用)， 以及它是否被认为是可“出⼝”加密算法。 

MAC 算法
	用于消息验证的算法。本规范包括该算法返回的哈希值的大小。
	
压缩算法
	用于压缩数据的算法。本规范必须包括该算法需要的进行压缩的所有信息。 

主密钥
	连接的两个对等体共享的48字节的密钥。
	
客户端随机数
	客户端产生的32字节的值。
	
服务端随机数
	服务端产生的32字节的值。

这些参数按照描述语言定义如下：
```
enum { server, client } ConnectionEnd;
enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;
enum { stream, block } CipherType;
enum { true, false } IsExportable;
enum { null, md5, sha } MACAlgorithm;
enum { null(0), (255) } CompressionMethod;
/* 指定的压缩、批加密以及MAC算法可能需要添加 */
```

```
struct {
	ConnectionEnd          entity;
	BulkCipherAlgorithm    bulk_cipher_algorithm;
	CipherType             cipher_type;
	uint8                  key_size;
	uint8                  key_material_length;
  IsExportable           is_exportable;
  MACAlgorithm           mac_algorithm;
  uint8                  hash_size
  CompressionMethod      compression_algorithm;
  opaque                 master_secret[48];
	opaque                 client_random[32];
  opaque                 server_random[32];
} SecurityParameters;
```
记录协议将使用这些安全参数来产生以下六项：
	客户端 写 MAC密钥 //session key
	服务端 写 MAC密钥
	客户端 写 密钥
	服务端 写 密钥
	客户端 写 初始向量 （仅用于分组加密）
	服务端 写 初始向量 （仅用于分组加密）
	
客户端的写参数将在服务端收到并处理记录时被服务端使用，反之亦然。使用安全参数生成以上项的算法将在[密钥计算]中描述。一旦安全参数和密钥被设定，连接状态就可以被实例化为当前状态。每次记录的处理都要更新当前状态。每个连接状态包含以下元素：

压缩状态
	当前压缩算法的状态。
	
加密状态
	当前加密算法的状态。包括该连接的预先设置的密钥。另外，对于运行在CBC模式下的分组加密（TLS唯一指定的模式），它最初包含该连接状态初始向量，并会更新为包含记录处理的最后一块加密或解密的密文，对于流加密，它将包含任何必要的信息，以继续流加密或解密数据。

MAC 密钥
	正如之前描述的产生的MAC 密钥。
	
序列号
	每个连接状态都包含一个序列号，读写状态的是分开维护的。无论什么时候连接状态设置为活动状态序列号都会设置为0。序列号是`uint64`类型的，不超过`2^64-1`，每次记录后序列号都会增加：特别的，在特定连接下发送的第一条记录应使用序列号0。
	
### 记录层
TLS记录层以任意大小的非空块接收高层的未解释的数据。

#### 分片
记录层将信息块分为携带2^14字节或更小的块的TLS明文记录。Client message boundaries are not preserved in the record layer.(例如，多个相同内容类型的客户端消息会被合并到一个TLS明文记录中，一条消息也可能被分片到多个记录中)
```
struct {
	uint8 major, minor;
} ProtocolVersion
```

```
enum {
	change_cipher_spec(20), alert(21), handshake(22),
	application_data(23), (255)
} Contenttype;
```

```
struct {
	ContentType type;
	ProtocolVersion version;
	uint16 length;
	opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
```

type
	高层协议用来处理 封闭的片段。

version
	协议部署的版本。本文档描述的是TLS 1.0版本，在这里使用版本{3, 1}，这是有历史原因的：TLS 1.0是在SSL 3.0上面进行较小改动的，因此继承了3.0这个版本号。（见附录A.1）
	
length
	后续TLSPlaintext.fragment 的长度（单位为字节）。长度不超过2^14。
	
fragment
	应用数据。这些数据是透明的，被视为独立的块，由类型字段指定的高层协议处理。
	
注意：不同TLS记录层内容类型的数据可能会交错。与其他内容类型相比，应⽤程序数据的传输优先级通常较低。

#### 记录压缩和解压缩
所有的记录都会以当前回话定义的压缩算法进行压缩，而且总会有一个活动的压缩算法，但一开始它被定义为`CompressionMethod.null`。压缩算法将`TLSPlaintext`结构转换为`TLSCompressed`结构。当一个连接状态被激活时压缩函数都会按照默认状态信息初始化。压缩必须是无损的，并且压缩后的内容长度不能增加超过1024字节。如果压缩函数遇到一个`TLSCompressed.fragment`，它将会解压到超过2^14字节的内容，这样会报告一个严重的解压失败错误。
```
struct {
	ContentType type;        /* 与 TLSPlaintext.type 相同 */
	ProtocolVersion version; /* 与 TLSPlaintext.version 相同 */
	uint16 length;
	opaque fragment[TLSCompressed.length];
} TLSCompressed;
```

length
	接下来的`TLSCompressed.fragment` 的长度（以字节为单位）。
	长度不能超过2^14+1024.
	
fragment
	`TLSPlaintext.fragment`的压缩形式。

注意：`CompressionMethod.null`是一个标识操作，不会有字段被改变。

实现注意：解压函数必须保证消息不回造成内部缓存溢出。

#### 记录载荷保护
加密和MAC函数将`TLSCompressed`结构转换为`TLSCiphertext`结构。解密函数是相反的操作。记录的消息验证码包含一个序列号，这样可以检测到丢失或额外的重复的消息。
```
struct {
	ContentType type;
	ProtocolVersion version;
	uint16 length;
	select (CipherSpec.cipher_type) {
		case stream: GenericStreamCipher;
		case block: GenericBlockCipher;
	} fragment;
} TLSCiphertext;
```

type
	`type`字段标识`TLSCompressed.type`。

version
	`version`字段标识`TLSCompressed.version`。
	
length
	接下来的`TLSCiphertext.fragment`的长度（以字节为单位）。
	长度不超过2^14+2048.
	
fragment
	`TLSCompressed.fragment`的带有MAC的加密形式。

##### 空或标准流加密

##### 密文分组链接块加密
### 密钥计算
#### 出口密钥生成示例
## TLS握手协议
### 密码规格变更协议
### 报警协议
#### 关闭报警
#### 错误报警
### 握手协议总览
### 握手协议
#### Hello消息
##### Hello请求
##### Client hello消息
##### Server hello消息
#### Server certificate消息
#### Server key exchange消息
#### Certificate request消息
#### Server hello done消息
#### Client certificate消息
#### Client key exchange消息
##### RSA加密的预主密钥消息
##### Client Diffie-Hellman公开值
#### Certificate verify消息
#### Finished消息
## 加密计算
### 计算主密钥
#### RSA
#### Diffie-Hellman
## 强制加密套件
## 应用数据协议
## 协议常量
### 记录层
### 密码规格变消息
### 警报消息
### 握手协议
#### Hello消息
#### 服务段验证和密钥交换消息
#### 客户段验证和密钥交换消息
#### 握手最终确认消息
### 加密套件
### 安全性参数
## 术语表
## 加密套件定义
## 实施说明
### 临时RSA密钥
### 随机数生成和种子
### 证书和验证
### 加密套件
## 对SSL的向后兼容
### Client hello消息的2.0版本
### 避免中间人的版本回滚
## 安全性分析
### 握手协议
#### 验证和密钥交换
##### 匿名密钥交换
##### RSA密钥交换和验证
##### Diffie-Hellman密钥交换和验证
#### 版本回滚攻击
#### 检测对握手协议的攻击
#### 恢复会话
#### MD5和SHA
### 保护应用数据
### 最终注意事项
## 显式声明

