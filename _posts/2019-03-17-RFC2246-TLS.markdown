---
layout:     post
title:      "The TLS Protocol V1.0"
subtitle:   "RFC2246"
date:       2019-03-17
author:     "XiaoYu"
header-img: "img/RFC2246.jpg"
tags:
    - Cyber Security
    - Protocol
    - RFC
---

> 对TLS协议的学习记录，本文为翻译。
> Copyright (C) The Internet Society (1999).  All Rights Reserved.

## 摘要
本文档规定了传输层安全协议(TLS)的1.0版本。TLS可以使互联网中的通信不受干扰。该协议允许客户端/服务器以一种能够防止窃听、篡改和消息伪造的方式进行通信。

## 引言
TLS协议的主要目标是在两个通信应用之间提供隐私保护和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。在最底层，在一些可靠的传输协议之上（如TCP），是TLS记录协议。TLS记录协议提供的安全连接有两个基本特性：

* 连接是私有的。对称加密用于数据加密（例如DES、RC4）。这种对称加密的密钥为每个连接唯⼀生成的，并且基于另一个协议协商的机密信息（如TLS握⼿手协议）。记录协议也可以在没有加密的情况下使⽤。
* 连接是可靠的。消息传输过程包括使用加密的MAC进行完整性校验。MAC计算使用一些安全的哈希函数（如SHA、MD5）。记录协议同样可以在没有MAC的情况下运行，但这通常仅在另一个协议利用记录协议作为传输工具来协商安全参数的时候才会发生。

TLS记录协议⽤于封装各种高级协议。 一个被封装的协议就是TLS握手协议，它允许服务器和客户端彼此认证，并在应⽤用协议发送或接收其第一个数据字节之前协商加密算法和加密密钥。TLS握手协议提供的安全连接有三个基本属性: 

* 对等实体的身份认证可以使用非对称加密或公钥加密（例如，RSA，DSS等）算法。该认证可以是可选的，但通常对于至少一个对等体是必需的。 
* 共享机密信息的协商是安全的：协商的机密信息不可被窃听者使用，并且对于任何经过身份验证的连接，即使能够将⾃己置于连接中的攻击者也⽆法获得该机密信息。 
* 协商是可靠的：没有攻击者可以在不被通信方发现的情况下修改协商通信。

TLS的一个优点是它与应⽤层协议无关。高层协议可以透明地层叠在TLS协议之上。然⽽，TLS标准没有指定协议如何使用TLS添加安全性; 关于如何初始化TLS握手过程以及如何解释交换的认证证书的决定取决于在TLS之上运⾏的协议的设计者和实现者的判断。 

## 目的
TLS协议的按优先级排列的目标：

1. 加密安全：TLS应该被用来建立参与双方的安全连接。
2. 互操作性：独立的程序员应该可以开发基于TLS的应用程序，并且可以成功交换加密参数而不需要了解彼此的代码。
3. 可扩展性：TLS旨在提供一个能将新的公钥加密和批量加密方法结合到一起的框架。这同时达到了一下两个子目标：避免了对新的协议的需要（且会引入新的风险）以及避免重新实现整个安全程序库。
4. 相对的效率：加密操作往往是CPU密集型的，特别是公钥加密。因此，TLS集成了一个可选的缓存技术以减少连接的建立次数。另外，减少网络活动也已被纳入考虑。

## 本文档的目的
本文档和TLS协议本身基于Netscape发布的SSL 3.0协议规范。TLS和SSL3.0的差异并不大，但它们之间是无法相互操作的（尽管设计了使TLS降级为SSL3.0的机制）。本文档主要面向要实现该协议的读者以及对它进行密码分析的人。因此本文档的写作目的也是为了上述两个人群的需要。所以很多独立于算法的数据结构和规则都被包含在文档主体中，这样可以方便的找到它们。

本文档并不是要提供服务或接口定义的细节，尽管它包含了维持安全性的一些策略。

## 描述语言
本文档使用外部形式表示数据的格式。将使用以下的十分基础的甚至有些随意的语法形式。语法结构采取自多个不同的来源。虽然它在语法上与C语言类似，并且亦或操作在语法和意图上都是类似的，但设置太多的类似并行语法是有风险的。描述语言只是用在本文档中，不应该有超出此目标的一般应用。

### 基本块的大小
所有数据项的表示形式都被明确指定了。最基本的数据块的大小为1字节。多字节的数据项是由单个字节串联而成的，从左到右，自顶向下。多字节数据项形式如下：
`value = (byte[0] << 8*(n-1) | (byte[1] << 8*(n-1)) | ... | byte[n-1])`
多字节项的字节顺序按照网络数据的`Big endian`格式。

### 其他
注释以`/*`开始，以`*/`结束。可选项使用两个方括号来包裹。包含未做解释的数据字节对象称为`opaque`类型。

### 向量
一个向量是一个同类数据元素的流（一维数组）。可以在编写文档时指定向量的大小，也可以在运行时指定。一般指定向量的字节数而不是数据类型的数量。指定新的类型`T`是固定长度向量的语法是：
`T  T'[n]`
这里的`T'`占据了`n`个字节，`n`是`T`的大小的倍数。 向量的长度不包括在编码流中。
在下面的例子中，`Datum`定义为三个连续的未做解释的字节，`Data`定义为3个连续的`Datum`，总共9个字节。
`opaque Datum[3];    /*3个未解释的字节*/`
`Datum Data[9];      /*3个连续的3字节向量*/`
可变长度的向量可以通过指定合法的的下标范围来定义，使用这种标注`<floor..ceiling>`。编码后，向量的实际长度会保存在实际内容的前面，长度将以一个数字的形式表示，消耗必要的字节数以保持向量的指定最大长度。长度字段为零的向量称为空向量。
`T T'<floor..ceiling>`
在下面的例子中，强制要求是一个向量必须包含300到400个`opaque`类型的字节。它不可能为空，实际长度字段为两个字节（UInt16），足以表示400的大小（见4.4节）。而且，可以表示到800字节的数据，400个UInt16类型元素，可能为空。编码形式在头部包含两个字节的长度字段。，编码后的长度必须是单个元素的长度的偶倍数。
`opaque mandatory<300..400>;  /*长度字段占两个字节，不能为空*/`
`uint16 longer<0..800>;       /*0到400个16比特的无符号整数*/`

### 数字
基本的数字数据类型是一个无符号的字节（uint8）。所有更大的数字数据都是固定的多个字节级联，同样是无符号的。下面是数字的类型：
`uint8 uint16[2]`
`uint8 uint24[3]`
`uint8 uint32[4]`
`uint8 uint64[8]`
所有值都以网络中的“大端”序存储，16进制的uint32`01020304`等于十进制`16909060`。

### 枚举
一种额外的稀疏数据类型称为枚举，枚举类型的字段只能是定义中声明的值，每个定义都是不同的类型。只有相同类型的枚举值才能被比较。每个枚举的元素都要赋值，如下所示。因为枚举的元素是无序的，它们可以以任意顺序赋不同的值。
`enum {e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;`
枚举在字节流中占⽤与其最大定义的值一样多的空间。以下定义将生成一个字节用于携带颜色类型的字段。 
`enum { red(3), blue(5), white(7) } Color;`
⼈们可以可选地指定一个没有关联标签的值来强制度定义而不定义多余的元素。在以下示例中，`Taste`将在数据流中消耗两个字节，但只能取值为1,2或4。 
`enum { sweet(1), sour(2), bitter(4), (32000) } Taste`
枚举的元素的名称在定义的类型范围内。在第一个示例中，对枚举的第二个元素的完全指定引用将是`Color.blue`。如果⽬标明确指定，则不需要这种指定。 
`Color color = Color.blue; /* overspecified, legal */`
`Color color = blue;       /* correct, type implicit */`
对于从未转换为外部表示的枚举，可以省略数字信息。
`enum { low, medium, high } Amount;`

### 构造类型
构造类型可以由原始类型创建。每个声明描述一种新的，独特的类型。定义的语法与`C`十分类似。
```
struct {
	T1 f1;
	T2 f2;
	...
	Tn fn;
} [[T]];
```
结构中的字段可以使用类型名进行限定，使用的语法非常类似于枚举的语法。例如，`T.f2`指之前定义的第二个字段。结构体的定义是可以嵌套的。

#### 变体
定义的结构可能基于环境中可用的一些信息具有变体。选择器必须是枚举类型，该类型定义了结构定义的可能变体。对于选择器中声明的枚举的每个元素，必须有一个`arm`情况。变体结构的主体可以给出一个标签以供引用。表示语言没有规定在运行时选择变体的机制。

### 加密属性
四种加密操作：数字签名、流密码加密、分组加密和公钥加密分别被指定为数字签名、流加密、分组加密和公钥加密。一个字段的加密处理是通过在字段的类型规范之前加上适当的关键字来指定的。加密密钥由当前会话状态指定（见连接状态）。

在数字签名中，单向哈希函数常用来作为数字签名的输入。数字签名编码为一个`opaque`向量`<0..2^16-1>`，它的长度由签名算法和密钥决定。

在RSA签名中，两个哈希值组成一个36字节的结构被签名（一个由SHA产生，一个由MD5产生）。它使用PKCS #1 块 类型0或类型1编码，如PKCS中所述。

在DSS中，SHA产生的20字节的哈希值直接通过数字签名算法，而没有额外的哈希。这将产生两个值，r和s。DSS的签名是一个`opaque`向量，它的内容是DER编码形式：
```
Dss-Sig-Value  ::=  SEQQUENCE  {
     r       INTEGER,
     s       INTEGER
}
```

在流密码加密中，明文与由安全密钥伪随机数产生器输出的相同大小的数据进行异或。

在分组加密中，每个明文分组被加密为一个密文分组。所有的分组加密过程都经过CBC（密文分组链接）模式完成，并且所有被加密的分组都是分组长度的倍数。

在公钥加密中，公钥加密算法加密的结果只能由对应的私钥解密。一个公钥加密元素被编码为`opaque`向量`<0..2^16-1>`，它的长度由签名算法和密钥指定。

一个RSA加密的数据以PKCS #1 分组类型2编码，如PKCS中的描述。

在如下的例子中：
```
stream-ciphered struct  {
    uint8 field1;
    uint8 field2;
    digitally-signed opaque hash[20];
} UserType;
```
哈希的内容被用作签名算法的输入，然后整个结构通过流密码加密。该结构的长度相当于`field1`和`field2`的两个字节以及两个字节的签名长度，还有签名算法的输出的长度，因为签名的算法和密钥都是已知的，那么长度也是已知的。

### 常量
可以通过为所需要的类型声明符号并赋值来定义常量类型。以下类型不能赋值(`opaque`，可变长向量，含有`opaque`的结构体)。无字段的多元素结构体或向量可以被省略。 
例如，
```
struct {
	uint8 f1;
	uint8 f2;
} Example1;

Example1 ex1 = {1, 4};
```

## HMAC和伪随机函数
TLS 记录层和握手层的一些操作需要用到带密钥的MAC，这是通过密钥保护的一些数据的安全摘要。不知道这个密钥是无法伪造MAC的。我们在这里使用HMAC，如[HMAC]的描述。

HMAC可以与各种不同的哈希算法一起使用。TLS在握手中使用两种：MD5和SHA-1，分别定义为HMAC_MD5(秘密，数据)和HMAC_SHA(秘密，数据)。额外的哈希算法可以定义在加密套件中，并用以保护记录数据，MD5和SHA-1被硬编码到该版本的握手协议中。

另外，为了密钥生成和验证，需要一种将私密信息扩展到数据块的构造方法。这个伪随机函数将私密信息，种子和身份标签作为输入并产生一个任意长度的输出。

为了伪随机函数尽可能的安全，它使用两种哈希算法，这样只要有一个足够安全就可以保证安全性。

首先，我们定义一个数据扩展函数，`P_hash(secret, data)`，它使用单个哈希函数将secret和seed扩展为任意数量的输出: 
```
P_hsah(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                       HMAC_hash(secret, A(2) + seed) +
                       HMAC_hash(secret, A(3) + seed) + ...
```
其中`+`指串连。
`A()`的定义如下：
```
A(0) = seed
A(i) = HMAC_hash(secret, A(i-1))
```

`P_hash`可以无限迭代以产生足够长度的输出数据。例如，如果使⽤`P_SHA-1`来创建64字节的数据，则必须迭代4次(通过A(4))，产生80字节的输出数据；最终迭代的最后16个字节将被丢弃，留下64个字节的输出数 据。 

TLS的伪随机函数是通过将私密信息分割成两半，其中一半用`P_MD5`生成数据，另一半⽤`P_SHA-1`生成数据， 然后将这两个扩展函数的输出进行异或。

S1和S2是私密信息的两半，每个都是相同的⻓度。 S1从secret的前半部分采取，S2是从下半部采取的。他们的长度是通过将私密信息的⻓度除以2来得出的; 因此，如果原始secret是奇数个字节长，则S1的最后⼀个字节 将与S2的第⼀个字节相同。 
 
 ```
 L_S = length in bytes of secret;
 L_S1 = L_S2 = ceil(L_S / 2);
 ```
 
如上所述，secret被分成两半(可能共享一个字节)，S1取第一个长为`L_S1`的字节，S2取最后一个长`L_S2`的字节。 

然后将PRF定义为将两个伪随机流混合在⼀起的结果。 
```
PRF(secret, label, seed) = P_MD5(S1, label+seed) XOR
                           P_SHA-1(S2, label+ seed);
```
标签是一个ASCII字符串。它应该被包括在给定的没有长度字节或尾随空字符的确切形式。 例如，label “slithy toves” 将通过哈希以下字节来处理: 
`73 6C 69 74 68 79 20 74 6F 76 65 73`

请注意，由于MD5产生16字节输出，SHA-1产生20字节输出，因此内部迭代的边界将不对齐; 为了生成80字节的输出，将`P_MD5`通过`A(5)`迭代，⽽`P_SHA-1`将仅迭代`A(4)`。

## TLS记录协议
### 连接状态
### 记录层
#### 分段
#### 记录压缩和解压缩
#### 记录载荷保护
##### 空或标准流加密
##### 密文分组链接块加密
### 密钥计算
#### 出口密钥生成示例
## TLS握手协议
### 密码规格变更协议
### 报警协议
#### 关闭报警
#### 错误报警
### 握手协议总览
### 握手协议
#### Hello消息
##### Hello请求
##### Client hello消息
##### Server hello消息
#### Server certificate消息
#### Server key exchange消息
#### Certificate request消息
#### Server hello done消息
#### Client certificate消息
#### Client key exchange消息
##### RSA加密的预主密钥消息
##### Client Diffie-Hellman公开值
#### Certificate verify消息
#### Finished消息
## 加密计算
### 计算主密钥
#### RSA
#### Diffie-Hellman
## 强制加密套件
## 应用数据协议
## 协议常量
### 记录层
### 密码规格变消息
### 警报消息
### 握手协议
#### Hello消息
#### 服务段验证和密钥交换消息
#### 客户段验证和密钥交换消息
#### 握手最终确认消息
### 加密套件
### 安全性参数
## 术语表
## 加密套件定义
## 实施说明
### 临时RSA密钥
### 随机数生成和种子
### 证书和验证
### 加密套件
## 对SSL的向后兼容
### Client hello消息的2.0版本
### 避免中间人的版本回滚
## 安全性分析
### 握手协议
#### 验证和密钥交换
##### 匿名密钥交换
##### RSA密钥交换和验证
##### Diffie-Hellman密钥交换和验证
#### 版本回滚攻击
#### 检测对握手协议的攻击
#### 恢复会话
#### MD5和SHA
### 保护应用数据
### 最终注意事项
## 显式声明

